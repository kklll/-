## 部分练习算法
- ### 1:盛最多水的容器
```给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。

图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```
 
![imag](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)
示例:
输入: [1,8,6,2,5,4,8,3,7]
输出: 49

- 题解 

算法:
- 这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。
我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 maxareamaxarea 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxareamaxarea，并将指向较短线段的指针向较长线段那端移动一步。
- 最初我们考虑由最外围两条线段构成的区域。现在，为了使面积最大化，我们需要考虑更长的两条线段之间的区域。如果我们试图将指向较长线段的指针向内侧移动，矩形区域的面积将受限于较短的线段而不会获得任何增加。但是，在同样的条件下，移动指向较短线段的指针尽管造成了矩形宽度的减小，但却可能会有助于面积的增大。因为移动较短线段的指针会得到一条相对较长的线段，这可以克服由宽度减小而引起的面积减小。
- 代码
```
public class Solution {
    public int maxArea(int[] height) {
        int maxarea = 0, l = 0, r = height.length - 1;
        while (l < r) {
            maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l));
            if (height[l] < height[r])
                l++;
            else
                r--;
        }
        return maxarea;
    }
}
```

- ### 2:二叉树的层平均值
```
输入:
    3
   / \
  9  20
    /  \
   15   7
输出: [3, 14.5, 11]
解释:
第0层的平均值是 3,  第1层是 14.5, 第2层是 11. 因此返回 [3, 14.5, 11].
```
- 解题思路：先创建队列,将头节点加入队列中，然后出队列，将头结点两端的节点加入队列中，
比如这样：
![PIC](https://img-blog.csdn.net/201808221719165?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbnNpb256/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- 代码
```
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
      queue<TreeNode*>que;
        vector<double>res;
        if(!root)return res;
        que.push(root);
        while(!que.empty()){
            int size = que.size();
            int tmp_size = size;
            double tmp = 0;
            while(size--){
                TreeNode* t = que.front();
                que.pop();
                if(t->left)que.push(t->left);
                if(t->right)que.push(t->right);
                tmp+=t->val;
            }
            res.push_back(tmp/tmp_size);
        }
        return res;
    }
};
```

- ####  3：实现 pow(x, n) ，即计算 x 的 n 次幂函数。

示例 1:
输入: 2.00000, 10
输出: 1024.00000

示例 2:
输入: 2.10000, 3
输出: 9.26100
- 解题思路：使用折半计算，每次把n缩小一半，这样n最终会缩小到0，任何数的0次方都为1，这时候我们再往回乘，如果此时n是偶数，直接把上次递归得到的值算个平方返回即可，如果是奇数，则还需要乘上个x的值。还有一点需要引起我们的注意的是n有可能为负数，对于n是负数的情况，我们可以先用其绝对值计算出一个结果再取其倒数即可。我们让i初始化为n，然后看i是否是2的倍数，是的话x乘以自己，否则res乘以x，i每次循环缩小一半，直到为0停止循环。最后看n的正负，如果为负，返回其倒数。



- 代码
```
class Solution {
    public double myPow(double x, int n) {
        double res = 1.0;
        for(int i = n; i != 0; i /= 2){
            if(i % 2 != 0){
                res *= x;
            }
            x *= x;
        }
        return  n < 0 ? 1 / res : res;
    }
}
```


- #### 4：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。（沙雕题目）



- 解题思路：暴力就完事了。



- 代码
```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int r[2];
int* twoSum(int* nums, int numsSize, int target) {
    int i=0,j=0;
    for(i=0;i<=numsSize-2;i++)
    {
        for(j=i+1;j<=numsSize-1;j++)
        {
            if(nums[i]+nums[j]==target)
            {
                r[0]=i;
                r[1]=j;
            }
        }
    }
    return r;
}
```

- #### 5：只出现一次的数字
给定一个整数数组，除了某个元素外其余元素均出现两次。请找出这个只出现一次的元素。

备注：

你的算法应该是一个线性时间复杂度。 你可以不用额外空间来实现它吗？

- 解题思路：
刚看到题的时候计划使用哈希表，这样一次就可以检索到只出现一次的元素，在网上看到高人的代码，跪下了。
根据计算机基础可以知道：& 两者同时为真才为真
0010 0100
&
0010 0100
=
0010 0100
由以上可得知，相同数字做&运算，会得到相同的数字。
两者一者为真就为真
0010 0100
|
0010 0100
=
0010 0100
由以上可得知，相同数字做|运算，会得到相同的数字。
^ 相同为假，不同为真
0010 0100
^
0010 0100
=
0000 0000
由以上可得知，相同数字做^异或运算，会得到0。
由此延伸到题目中，可以得知，若存在一个数字只出现一次，那么该数组所有元素异或结果大于0.
--------------------- 

原文：https://blog.csdn.net/biezhihua/article/details/79571917 


- 代码
```
int singleNumber(int* nums, int numsSize) {
    int res=0;
    int i=0;
    for(i=0;i<numsSize;i++)
    {
        res ^= nums[i];
    }
    return res;
}
```




---


- #### 6：求众数

- 解题思路：用一种叫摩尔投票法 Moore Voting，需要O(n)的时间和O(1)的空间，这种投票法先将第一个数字假设为众数，然后把计数器设为1，比较下一个数和此数是否相等，若相等则计数器加一，反之减一。然后看此时计数器的值，若为零，则将下一个值设为候选众数。以此类推直到遍历完整个数组，当前候选众数即为该数组的众数。不仔细弄懂摩尔投票法的精髓的话，过一阵子还是会忘记的，首先要明确的是这个叼炸天的方法是有前提的，就是数组中一定要有众数的存在才能使用，下面我们来看本算法的思路，这是一种先假设候选者，然后再进行验证的算法。我们现将数组中的第一个数假设为众数，然后进行统计其出现的次数，如果遇到同样的数，则计数器自增1，否则计数器自减1，如果计数器减到了0，则更换下一个数字为候选者。这是一个很巧妙的设定，也是本算法的精髓所在，为啥遇到不同的要计数器减1呢，为啥减到0了又要更换候选者呢？首先是有那个强大的前提存在，一定会有一个出现超过半数的数字存在，那么如果计数器减到0了话，说明目前不是候选者数字的个数已经跟候选者的出现个数相同了，那么这个候选者已经很weak，不一定能出现超过半数，我们选择更换当前的候选者。那有可能你会有疑问，那万一后面又大量的出现了之前的候选者怎么办，不需要担心，如果之前的候选者在后面大量出现的话，其又会重新变为候选者，直到最终验证成为正确的众数。

这个算法吊炸天。
- 代码
```
class Solution {
    public int majorityElement(int[] nums) {
        int res=0,count=0;
        for(int num:nums)
        {
            if(count==0){
                res=num;
                count++;
            }
            else if(num==res)
            {
                count++;
            }
            else
            {
                count--;
            }
        }
        return res;
    }
}
```

- #### 7：删除排序数组中的重复项

- 解题思路：算法
数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]nums[i]=nums[j]，我们就增加 j 以跳过重复项。


- 代码
```
public int removeDuplicates(int[] nums) {
    if (nums.length == 0) return 0;
    int i = 0;
    for (int j = 1; j < nums.length; j++) {
        if (nums[j] != nums[i]) {
            i++;
            nums[i] = nums[j];
        }
    }
    return i + 1;
}
```


- #### 8：

- 解题思路：


- 代码
```

```

- #### 9：

- 解题思路：


- 代码
```

```
## 持续更新中！
- #### 10：

- 解题思路：


- 代码
```

```