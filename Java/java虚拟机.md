

## 《深入理解java虚拟机》读书笔记

<!-- TOC -->

- [《深入理解java虚拟机》读书笔记](#深入理解java虚拟机读书笔记)
    - [java内存区域与内存溢出异常](#java内存区域与内存溢出异常)
        - [Java虚拟机栈（平时的栈区）](#java虚拟机栈平时的栈区)
        - [Java堆](#java堆)
        - [方法区](#方法区)
        - [运行时常量池](#运行时常量池)
        - [直接内存](#直接内存)
        - [对象的布局](#对象的布局)
        - [对象的访问定位](#对象的访问定位)

<!-- /TOC -->

### java内存区域与内存溢出异常

#### Java虚拟机栈（平时的栈区）
- 如果线程正在执行的是一个native方法（通过调用其他语言或者资源的方法）则再Java程序计数器中PC为空。
- Java虚拟机栈是线程私有的，它的生命周期与线程想同。虚拟机描述的谁Java方法的内存模型用于存储局部变量表、操作数栈、动态链接、方法接口等信息
- 存放各种基本数据类型、对象类型、或者returnAddress类型（指向了一条字节码指令的地址）

#### Java堆
- 在Java虚拟机规范中的描述是:所有的对象实例以及数组都必须要在堆上分配
- Java堆中的内存只要在逻辑上是连续的就可以

#### 方法区
- 方法区和Java堆一样，是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译系统编译后的代码数据等等
  
#### 运行时常量池

- 运行时常量池是是方法区的一部分。Class方法除了有类的版本、字段、方法、接口等信息的描述，还有就是常量池，用来存放编译生成的各种字面量和符号引用，用于在类加载后进入方法区中的常量池中进行存放。
- 运行时常量池并非在编译成为class文件时候才能确定，在运行过程中也可以进行常量池的一些操作，比如String的intern()方法。

#### 直接内存
- 直接内存不是Java虚拟机运行时的数据区部分。但是这些内存区域频繁的被使用，比如I/O流中的Buffer。

#### 对象的布局
- 在Hotspot虚拟机中，对象在内存中存储的布局可分为三部分：对象头、实例数据、对齐填充
   - 对象头:包括两部分内容，第一部分是存储对象自身运行时所需的一些数据，如hashcode，GC分代年龄、锁标志、线程持有的锁、偏向线程ID等，第二部分就是类型指针，即对象指向它的类元数据的指针，虚拟机通过此来进行检测该对象是哪个类的实例（但是不一定寻找对象的额元数据信息就一定要经过对象本身）长度为32bit或者64bit。
   - 第二部分对象数据部分：即对象的实体数据部分，无论是在父类中继承的数据还是在子类中定义的内容。Hotspot的默认分配策略是longs/double、ints、shorts/chars、bytes、Booleans、oops（对象指针）
   - 第三部分即为对齐部分，由于对象头已经是8字节的整数位，那么当
对象的数据部分没有对齐的时候，需要使用此字段来进行对齐操作。

#### 对象的访问定位
目前主流的对对象定位的方法有两种，分别是句柄访问和直接指针
- 句柄访问:如果采用句柄访问，在Java的堆中会分配一块内存作为句柄池，reference（指向对象的引用）中存储的就是对象的句柄地址，句柄池中存放的是到`对象实例数据的指针`和到`对象类型数据的指针`，其中对象类型数据在方法区中存放。
- 直接指针:在直接定位中reference中存储的是对象的逻辑地址，通过访问对象的逻辑地址来得到`对象类型数据的指针`和`实例数据`

这两种方式各有千秋，使用句柄访问时，当对象被移动时只会改变句柄的示例数据指针，其他不必修改。而指针访问就一个特点——快

